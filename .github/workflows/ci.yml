name: CI

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 2.2.1
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --with dev
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'

      - name: Install dependencies (cached)
        run: poetry install --with dev --no-root
        if: steps.cached-poetry-dependencies.outputs.cache-hit == 'true'

      - name: Run Black (format check)
        run: poetry run black --check app tests

      - name: Run Ruff (linting)
        run: poetry run ruff check app tests

  type-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 2.2.1
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --with dev
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'

      - name: Install dependencies (cached)
        run: poetry install --with dev --no-root
        if: steps.cached-poetry-dependencies.outputs.cache-hit == 'true'

      - name: Run MyPy (type checking)
        run: poetry run mypy app

  test:
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpassword
          MYSQL_DATABASE: qpeptide_cutter_test
          MYSQL_USER: testuser
          MYSQL_PASSWORD: testpassword
        ports:
          - 3306:3306
        options: >-
          --health-cmd "mysqladmin ping -h localhost"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 2.2.1
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --with dev
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'

      - name: Install dependencies (cached)
        run: poetry install --with dev --no-root
        if: steps.cached-poetry-dependencies.outputs.cache-hit == 'true'

      - name: Run tests
        env:
          DATABASE_URL: mysql+pymysql://testuser:testpassword@localhost:3306/qpeptide_cutter_test
          CI: true
        run: poetry run pytest tests/ -v --tb=short

  build-and-test:
    runs-on: ubuntu-latest
    needs: [lint, type-check, test]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: qpeptide-cutter-backend:test
          cache-from: type=gha
          cache-to: type=gha,mode=max
          load: true  # Load image into local Docker daemon for testing

      - name: Test Docker image
        run: |
          # Verify image was built
          docker images | grep qpeptide-cutter-backend

          # Test that the container starts (with a timeout)
          timeout 30 docker run --rm \
            -e DATABASE_URL="mysql+pymysql://test:test@host.docker.internal:3306/test" \
            qpeptide-cutter-backend:test \
            uvicorn app.main:app --host 0.0.0.0 --port 8000 &

          # Wait a moment for startup
          sleep 5

          # Check if process is still running (container started successfully)
          if ps aux | grep -q "[u]vicorn"; then
            echo "✅ Container started successfully"
            pkill -f uvicorn || true
          else
            echo "❌ Container failed to start"
            exit 1
          fi

      - name: Validate image metadata
        run: |
          # Check image size (optional - warn if too large)
          IMAGE_SIZE=$(docker images qpeptide-cutter-backend:test --format "{{.Size}}")
          echo "Image size: $IMAGE_SIZE"

          # Verify working directory
          docker run --rm qpeptide-cutter-backend:test pwd | grep -q "/app" && echo "✅ Working directory correct"

          # Verify Python version
          docker run --rm qpeptide-cutter-backend:test python --version | grep -q "Python 3.13" && echo "✅ Python version correct"
