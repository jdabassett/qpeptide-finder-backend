name: Deploy to EC2

on:
  workflow_run:
    workflows: ["Run Database Migrations"]
    types:
      - completed
    branches:
      - main

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  BACKEND_ECR_REPOSITORY: ${{ secrets.BACKEND_ECR_REPOSITORY }}
  FRONTEND_ECR_REPOSITORY: ${{ secrets.FRONTEND_ECR_REPOSITORY }}

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest

    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get workflow run details
        id: workflow-run
        uses: actions/github-script@v7
        with:
          script: |
            const migrationRun = context.payload.workflow_run;
            const commitSha = migrationRun.head_sha;
            core.setOutput('result', commitSha);
            return commitSha;

      - name: Get latest frontend image tag
        id: get-frontend-tag
        run: |
          FRONTEND_TAG=$(aws ecr describe-images \
            --repository-name ${{ env.FRONTEND_ECR_REPOSITORY }} \
            --region ${{ env.AWS_REGION }} \
            --query 'sort_by(imageDetails,&imagePushedAt)[-1].imageTags[0]' \
            --output text 2>/dev/null || echo "latest")

          if [ "$FRONTEND_TAG" = "None" ] || [ -z "$FRONTEND_TAG" ]; then
            FRONTEND_TAG="latest"
          fi

          echo "frontend_tag=${FRONTEND_TAG}" >> $GITHUB_OUTPUT
          echo "Using frontend tag: ${FRONTEND_TAG}"

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Add EC2 to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to EC2
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          BACKEND_TAG: ${{ steps.workflow-run.outputs.result || github.event.workflow_run.head_sha }}
          FRONTEND_TAG: ${{ steps.get-frontend-tag.outputs.frontend_tag }}
          BACKEND_ECR_REPO: ${{ env.BACKEND_ECR_REPOSITORY }}
          FRONTEND_ECR_REPO: ${{ env.FRONTEND_ECR_REPOSITORY }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} <<'ENDSSH'
            set -e

            # Get the actual EC2 username
            EC2_USERNAME=$(whoami)

            # Create deployment directory structure with proper permissions
            sudo mkdir -p /opt/qpeptide/deploy/nginx
            sudo chown -R $EC2_USERNAME:$EC2_USERNAME /opt/qpeptide

            # Ensure no stale Docker Hub credentials remain
            docker logout docker.io >/dev/null 2>&1 || true
            docker logout https://registry-1.docker.io/v2/ >/dev/null 2>&1 || true

            # Login to ECR
            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin "$ECR_REGISTRY"

            # Pull latest images
            echo "ðŸ“¥ Pulling backend image..."
            docker pull "$ECR_REGISTRY/$BACKEND_ECR_REPO:$BACKEND_TAG" || {
              echo "âš ï¸ Backend image not found, using latest"
              docker pull "$ECR_REGISTRY/$BACKEND_ECR_REPO:latest" || true
            }

            echo "ðŸ“¥ Pulling frontend image..."
            docker pull "$ECR_REGISTRY/$FRONTEND_ECR_REPO:$FRONTEND_TAG" || {
              echo "âš ï¸ Frontend image not found, using latest"
              docker pull "$ECR_REGISTRY/$FRONTEND_ECR_REPO:latest" || true
            }

            # Tag as latest for docker-compose
            docker tag "$ECR_REGISTRY/$BACKEND_ECR_REPO:$BACKEND_TAG" "$ECR_REGISTRY/$BACKEND_ECR_REPO:latest" 2>/dev/null || true
            docker tag "$ECR_REGISTRY/$FRONTEND_ECR_REPO:$FRONTEND_TAG" "$ECR_REGISTRY/$FRONTEND_ECR_REPO:latest" 2>/dev/null || true

            # Clean up old images
            docker image prune -f
          ENDSSH

      - name: Upload infrastructure files
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "deploy/"
          target: "/opt/qpeptide/"
          strip_components: 1

      - name: Start services with docker-compose
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            cd /opt/qpeptide/deploy

            # Set environment variables for docker-compose
            export ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
            export BACKEND_ECR_REPO="${{ env.BACKEND_ECR_REPOSITORY }}"
            export FRONTEND_ECR_REPO="${{ env.FRONTEND_ECR_REPOSITORY }}"
            export AWS_REGION="${{ env.AWS_REGION }}"
            export EC2_HOST="${{ secrets.EC2_HOST }}"
            export API_KEY="${{ secrets.API_KEY }}"

            # Ensure docker-compose is available (install if needed)
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing docker-compose..."
              curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
            fi

            # Stop old containers if they exist
            docker-compose -f docker-compose.prod.yml down || true

            # Pull latest images
            docker-compose -f docker-compose.prod.yml pull || true

            # Start services
            docker-compose -f docker-compose.prod.yml up -d

            # Wait for services to be healthy
            sleep 10

            # Check service status
            docker-compose -f docker-compose.prod.yml ps

            # Health check
            echo "ðŸ¥ Checking health endpoints..."
            sleep 15

            MAX_ATTEMPTS=5
            ATTEMPT=1
            while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
              echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
              if curl -f -m 5 "http://localhost/health" > /dev/null 2>&1; then
                echo "âœ… Health check passed"
                break
              else
                if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                  echo "âš ï¸ Health check failed after $MAX_ATTEMPTS attempts"
                  echo "ðŸ“‹ Container logs:"
                  docker-compose -f docker-compose.prod.yml logs --tail 50
                  exit 1
                fi
                sleep 5
                ATTEMPT=$((ATTEMPT + 1))
              fi
            done

            echo "ðŸŽ‰ Deployment complete!"

      - name: Deployment summary
        run: |
          echo "### Deployment Complete :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**EC2 Instance:** \`${{ secrets.EC2_HOST }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Backend Image:** \`${{ steps.login-ecr.outputs.registry }}/${{ env.BACKEND_ECR_REPOSITORY }}:${{ steps.workflow-run.outputs.result }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Image:** \`${{ steps.login-ecr.outputs.registry }}/${{ env.FRONTEND_ECR_REPOSITORY }}:${{ steps.get-frontend-tag.outputs.frontend_tag }}\`" >> $GITHUB_STEP_SUMMARY
